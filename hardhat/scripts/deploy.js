const hre = require("hardhat");
require("dotenv").config();

const fs = require("fs");
const fsp = require("fs/promises");
const path = require("path");

const FRONTEND_ROOT = path.resolve(__dirname, "..", "..", "frontend");
const FRONTEND_CONTRACT_DIR = path.join(FRONTEND_ROOT, "public", "contract");

const NETWORK_METADATA = {
  hardhat: {
    chainId: 31337,
    name: "Hardhat",
    explorerUrl: "http://localhost:8545",
    publicRpcUrl: "http://127.0.0.1:8545",
  },
  localhost: {
    chainId: 1337,
    name: "Localhost",
    explorerUrl: "http://localhost:8545",
    publicRpcUrl: "http://127.0.0.1:8545",
  },
  sepolia: {
    chainId: 11155111,
    name: "Ethereum Sepolia",
    explorerUrl: "https://sepolia.etherscan.io",
    publicRpcUrl: process.env.SEPOLIA_RPC_URL || "https://sepolia.drpc.org",
  },
  baseSepolia: {
    chainId: 84532,
    name: "Base Sepolia",
    explorerUrl: "https://sepolia.basescan.org",
    publicRpcUrl: process.env.BASE_SEPOLIA_RPC_URL || "https://sepolia.base.org",
  },
};

const sanitizeNetworkKey = (networkName) =>
  networkName.replace(/[^a-zA-Z0-9]/g, "_").toUpperCase();

const buildIntegrationConfig = (networkName) => {
  const key = sanitizeNetworkKey(networkName);
  const routerEnvKey = `UNISWAP_ROUTER_ADDRESS_${key}`;
  const lemonEnvKey = `LEMON_API_URL_${key}`;

  const routerAddress =
    process.env[routerEnvKey] || process.env.UNISWAP_ROUTER_ADDRESS || "";
  const lemonApiUrl =
    process.env[lemonEnvKey] || process.env.LEMON_API_URL || "";

  if (!routerAddress) {
    console.warn(
      `[deploy][warn] No Uniswap router configured for ${networkName}. Set ${routerEnvKey} or UNISWAP_ROUTER_ADDRESS.`
    );
  }

  if (!lemonApiUrl) {
    console.warn(
      `[deploy][warn] No Lemon API URL configured for ${networkName}. Set ${lemonEnvKey} or LEMON_API_URL.`
    );
  }

  return {
    uniswap: {
      supported: Boolean(routerAddress), // True if a router address is set
      routerAddress, // The Uniswap router address
      envKey: routerEnvKey, // The environment variable key used
    },
    lemon: {
      supported: Boolean(lemonApiUrl), // True if a Lemon API URL is set
      apiBaseUrl: lemonApiUrl, // The Lemon API URL
      envKey: lemonEnvKey, // The environment variable key used
    },
  };
};

const ensureDir = async (dirPath) => {
  await fsp.mkdir(dirPath, { recursive: true });
};

const writeJson = async (target, payload) => {
  await fsp.writeFile(target, JSON.stringify(payload, null, 2));
};

const getNetworkMeta = (networkName, fallbackChainId) => {
  return (
    NETWORK_METADATA[networkName] || {
      chainId: fallbackChainId || 0,
      name: networkName,
      explorerUrl: "",
      publicRpcUrl: hre.network.config?.url || "",
    }
  );
};

const sanitizeDeploymentInfo = ({
  contractName,
  address,
  network,
  chainId,
  explorerUrl,
  publicRpcUrl,
  blockNumber,
  txHash,
  integrations,
}) => ({
  contractName,
  address,
  network,
  chainId,
  explorerUrl,
  publicRpcUrl,
  blockNumber,
  txHash,
  generatedAt: new Date().toISOString(),
  abiFile: "CakeFactory.abi.json",
  integrations,
});

const writeFrontendArtifacts = async (abi, deploymentInfo) => {
  await ensureDir(FRONTEND_CONTRACT_DIR);

  const abiPath = path.join(FRONTEND_CONTRACT_DIR, "CakeFactory.abi.json");
  await writeJson(abiPath, abi);

  const perNetworkPath = path.join(
    FRONTEND_CONTRACT_DIR,
    `CakeFactory.${deploymentInfo.network}.deployment.json`
  );
  await writeJson(perNetworkPath, { ...deploymentInfo, abi });

  const manifestPath = path.join(
    FRONTEND_CONTRACT_DIR,
    "deployments.manifest.json"
  );
  let manifest = {};
  if (fs.existsSync(manifestPath)) {
    try {
      manifest = JSON.parse(await fsp.readFile(manifestPath, "utf-8"));
    } catch (error) {
      console.warn(
        `[deploy][warn] Unable to parse existing manifest, recreating file. (${error.message})`
      );
    }
  }
  manifest[deploymentInfo.network] = deploymentInfo;
  await writeJson(manifestPath, manifest);
};

const updateFrontendEnv = async (deploymentInfo) => {
  await ensureDir(FRONTEND_ROOT);
  const envPath = path.join(FRONTEND_ROOT, ".env.example");

  const lines = [
    "# Auto-generated by hardhat/scripts/deploy.js",
    `# Network: ${deploymentInfo.network} (${deploymentInfo.chainId})`,
    `CONTRACT_ADDRESS=${deploymentInfo.address}`,
    `NEXT_PUBLIC_CONTRACT_ADDRESS=${deploymentInfo.address}`,
    `NEXT_PUBLIC_CHAIN_ID=${deploymentInfo.chainId}`,
    `NEXT_PUBLIC_NETWORK_NAME=${deploymentInfo.network}`,
    `NEXT_PUBLIC_RPC_URL=${deploymentInfo.publicRpcUrl || ""}`,
    `NEXT_PUBLIC_UNISWAP_ROUTER=${deploymentInfo.integrations.uniswap.routerAddress || ""
    }`,
    `NEXT_PUBLIC_LEMON_API_URL=${deploymentInfo.integrations.lemon.apiBaseUrl || ""
    }`,
    "",
    "# Update the values above or copy to .env.local",
  ];

  await fsp.writeFile(envPath, lines.join("\n"));
};

async function main() {
  const networkName = hre.network.name;
  const chainId = hre.network.config?.chainId;
  const meta = getNetworkMeta(networkName, chainId);
  const integrations = buildIntegrationConfig(networkName);

  console.log(
    `[deploy] Deploying CakeFactory to ${meta.name} (${networkName})...`
  );

  const CakeFactory = await hre.ethers.getContractFactory("CakeFactory");
  const contract = await CakeFactory.deploy();
  await contract.waitForDeployment();
  const address = await contract.getAddress();
  const deploymentTx = contract.deploymentTransaction();
  const receipt = await deploymentTx.wait();

  console.log(
    `[deploy] CakeFactory deployed at ${address} (tx: ${receipt.hash})`
  );

  const artifact = await hre.artifacts.readArtifact("CakeFactory");

  const deploymentInfo = sanitizeDeploymentInfo({
    contractName: "CakeFactory",
    address,
    network: networkName,
    chainId: meta.chainId,
    explorerUrl: meta.explorerUrl,
    publicRpcUrl: meta.publicRpcUrl,
    blockNumber: receipt.blockNumber,
    txHash: receipt.hash,
    integrations,
  });

  await writeFrontendArtifacts(artifact.abi, deploymentInfo);
  await updateFrontendEnv(deploymentInfo);

  console.log(
    `[deploy] Frontend artifacts refreshed under ${FRONTEND_CONTRACT_DIR}`
  );
}

main().catch((error) => {
  console.error("[deploy][error]", error);
  process.exitCode = 1;
});
